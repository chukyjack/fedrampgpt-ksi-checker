"""GitHub Check Run management."""

from typing import Any

import httpx

from app.config import get_settings
from app.github_auth import github_auth
from shared.constants import CHECK_RUN_NAME, CHECK_RUN_TITLE, KSI_REQUIREMENT_TEXT


def status_to_conclusion(status: str) -> str:
    """Map KSI status to GitHub Check Run conclusion.

    Args:
        status: KSI status (PASS, FAIL, ERROR)

    Returns:
        GitHub conclusion string
    """
    mapping = {
        "PASS": "success",
        "FAIL": "failure",
        "ERROR": "neutral",  # As per spec, use neutral for errors
    }
    return mapping.get(status, "neutral")


def build_check_run_summary(
    manifest: dict[str, Any],
    artifact_name: str | None = None,
    run_url: str | None = None,
) -> str:
    """Build the Check Run summary markdown.

    Uses locked FedRAMP wording as specified.

    Args:
        manifest: Evaluation manifest dict
        artifact_name: Name of the evidence artifact
        run_url: URL to the workflow run

    Returns:
        Markdown summary string
    """
    status = manifest.get("status", "UNKNOWN")
    scope = manifest.get("scope", {})
    process = manifest.get("process", {})
    criteria = manifest.get("criteria", [])

    # Status emoji
    status_emoji = {"PASS": "✅", "FAIL": "❌", "ERROR": "⚠️"}.get(status, "❓")

    lines = [
        f"## {status_emoji} KSI-MLA-05: Evaluate Configuration",
        "",
        "### Requirement",
        f"> {KSI_REQUIREMENT_TEXT}",
        "",
        f"### Status: **{status}**",
        "",
    ]

    # Reasons
    reasons = manifest.get("reasons", [])
    if reasons:
        lines.append("### Summary")
        for reason in reasons:
            lines.append(f"- {reason}")
        lines.append("")

    # Criteria results
    lines.append("### Criteria Evaluation")
    lines.append("")
    lines.append("| Criterion | Name | Status | Reason |")
    lines.append("|-----------|------|--------|--------|")

    for criterion in criteria:
        crit_status = criterion.get("status", "UNKNOWN")
        crit_emoji = {
            "PASS": "✅",
            "FAIL": "❌",
            "ERROR": "⚠️",
            "SKIP": "⏭️",
        }.get(crit_status, "❓")
        lines.append(
            f"| {criterion.get('id', 'N/A')} | {criterion.get('name', 'N/A')} | {crit_emoji} {crit_status} | {criterion.get('reason', 'N/A')} |"
        )

    lines.append("")

    # Scope
    lines.append("### Scope")
    lines.append(f"- **Repository:** {scope.get('repository', 'N/A')}")
    lines.append(f"- **Commit:** `{scope.get('commit_sha', 'N/A')[:7]}`")
    lines.append(f"- **Configuration Surfaces:** {', '.join(scope.get('configuration_surfaces', []))}")
    tf_paths = scope.get("terraform_paths", [])
    if tf_paths:
        lines.append(f"- **Terraform Paths:** {', '.join(tf_paths)}")
    lines.append("")

    # Process
    lines.append("### Process")
    lines.append(f"- **Workflow:** {process.get('workflow_name', 'N/A')}")
    lines.append(f"- **Trigger:** `{process.get('trigger_event', 'N/A')}`")
    if run_url:
        lines.append(f"- **Run:** [{process.get('workflow_run_id', 'N/A')}]({run_url})")
    else:
        lines.append(f"- **Run ID:** {process.get('workflow_run_id', 'N/A')}")
    lines.append(f"- **Actor:** {process.get('actor', 'N/A')}")
    lines.append("")

    # Evidence artifact
    if artifact_name:
        lines.append("### Evidence Artifact")
        lines.append(f"- **Name:** `{artifact_name}`")
        lines.append("")

    # Footer
    lines.append("---")
    lines.append("*Generated by FedRAMP 20x KSI Evidence Action*")

    return "\n".join(lines)


async def create_check_run(
    installation_id: int,
    owner: str,
    repo: str,
    head_sha: str,
    manifest: dict[str, Any],
    artifact_name: str | None = None,
    run_url: str | None = None,
) -> dict[str, Any]:
    """Create a Check Run for KSI evaluation results.

    Args:
        installation_id: GitHub App installation ID
        owner: Repository owner
        repo: Repository name
        head_sha: Commit SHA to attach check to
        manifest: Evaluation manifest
        artifact_name: Name of the evidence artifact
        run_url: URL to the workflow run

    Returns:
        Created check run data
    """
    token = await github_auth.get_installation_token(installation_id)
    settings = get_settings()

    status = manifest.get("status", "ERROR")
    conclusion = status_to_conclusion(status)
    summary = build_check_run_summary(manifest, artifact_name, run_url)

    payload = {
        "name": CHECK_RUN_NAME,
        "head_sha": head_sha,
        "status": "completed",
        "conclusion": conclusion,
        "output": {
            "title": CHECK_RUN_TITLE,
            "summary": summary,
        },
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{settings.github_api_url}/repos/{owner}/{repo}/check-runs",
            headers=github_auth.get_headers(token),
            json=payload,
        )
        response.raise_for_status()

    return response.json()


async def update_check_run(
    installation_id: int,
    owner: str,
    repo: str,
    check_run_id: int,
    manifest: dict[str, Any],
    artifact_name: str | None = None,
    run_url: str | None = None,
) -> dict[str, Any]:
    """Update an existing Check Run.

    Args:
        installation_id: GitHub App installation ID
        owner: Repository owner
        repo: Repository name
        check_run_id: ID of the check run to update
        manifest: Evaluation manifest
        artifact_name: Name of the evidence artifact
        run_url: URL to the workflow run

    Returns:
        Updated check run data
    """
    token = await github_auth.get_installation_token(installation_id)
    settings = get_settings()

    status = manifest.get("status", "ERROR")
    conclusion = status_to_conclusion(status)
    summary = build_check_run_summary(manifest, artifact_name, run_url)

    payload = {
        "status": "completed",
        "conclusion": conclusion,
        "output": {
            "title": CHECK_RUN_TITLE,
            "summary": summary,
        },
    }

    async with httpx.AsyncClient() as client:
        response = await client.patch(
            f"{settings.github_api_url}/repos/{owner}/{repo}/check-runs/{check_run_id}",
            headers=github_auth.get_headers(token),
            json=payload,
        )
        response.raise_for_status()

    return response.json()


async def find_existing_check_run(
    installation_id: int,
    owner: str,
    repo: str,
    head_sha: str,
) -> dict[str, Any] | None:
    """Find an existing check run for a commit.

    Args:
        installation_id: GitHub App installation ID
        owner: Repository owner
        repo: Repository name
        head_sha: Commit SHA

    Returns:
        Check run data or None if not found
    """
    token = await github_auth.get_installation_token(installation_id)
    settings = get_settings()

    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"{settings.github_api_url}/repos/{owner}/{repo}/commits/{head_sha}/check-runs",
            headers=github_auth.get_headers(token),
            params={"check_name": CHECK_RUN_NAME},
        )
        response.raise_for_status()
        data = response.json()

    check_runs = data.get("check_runs", [])
    if check_runs:
        return check_runs[0]

    return None
